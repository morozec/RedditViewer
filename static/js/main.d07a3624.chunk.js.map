{"version":3,"sources":["store/topics/actionTypes.js","services/reddit.js","store/topics/reducer.js","components/ListView.js","components/ListRow.js","containers/TopicsScreen.js","store/topics/actions.js","store/posts/actionTypes.js","store/posts/reducer.js","components/TopicFilter.js","components/PostView.js","containers/PostsScreen.js","store/posts/actions.js","App.js","serviceWorker.js","index.js"],"names":["TOPICS_FETCHED","TOPICS_SELECTED","TOPICS_SELECTION_FINILIZED","url","fetch","method","headers","Accept","response","ok","Error","status","json","data","children","_","get","map","subreddit","title","description","subredditUrl","post","body","id","topicUrl","thumbnail","_validateUrl","undefined","startsWith","initialState","Immutable","topicsByUrl","selectedTopicUrls","selectionFinalized","reduce","state","action","type","types","merge","getTopicsByUrl","topics","getTopicsUrlArray","keys","getSelectedTopicUrls","getSelectedTopicsByUrl","mapValues","keyBy","isTopicSelectionValid","length","isTopicSelectionFinalized","ListView","props","rowsIdArray","rowId","renderRow","rowsById","key","renderRowById","ListRow","backgroundColor","selected","style","onClick","connect","topicsSelectors","selectedRowsById","canFinalizeSelction","console","log","dispatch","useEffect","getState","a","redditService","getDefaultSubreddits","subredditArray","error","onRowClick","selectedTopics","indexOf","newSelectedTopics","concat","slice","className","row","POSTS_FETCHED","FILTER_CHANGED","POST_SELECTED","postsById","currentFilter","currentPostId","filter","postId","getCurrentFilter","posts","getCurrentPost","TopicFilter","renderFilter","label","href","onFilterClick","onChanged","topic","topicId","PostView","this","renderBody","_isImage","renderImage","renderUrl","renderEmpty","dangerouslySetInnerHTML","_getBodyMarkup","src","alt","target","__html","replace","match","dec","String","fromCharCode","endsWith","Component","postsIdArray","postsSelectors","rowIdArray","currentPost","selectedTopicsUrls","fetchedPromises","getPostsFromSubreddit","Promise","all","topicsPosts","flatten","newFilter","postsActions","isSelectionFinilized","Boolean","window","location","hostname","store","createStore","combineReducers","reducers","applyMiddleware","thunk","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d07a3624.chunk.js","sourcesContent":["export const TOPICS_FETCHED = 'topics.TOPICS_FETCHED';\r\nexport const TOPICS_SELECTED = 'topics.TOPICS_SELECTED';\r\nexport const TOPICS_SELECTION_FINILIZED = 'topics.TOPICS_SELECTION_FINILIZED';","// services are state-less\r\n// they act as utility facades that abstract the details for complex operations\r\n// normally, our interface to any sort of server API will be as a service\r\n\r\nimport _ from 'lodash';\r\n\r\nconst REDDIT_ENDPOINT = 'https://www.reddit.com';\r\n\r\nclass RedditService {\r\n    async getDefaultSubreddits() {\r\n        const url = `${REDDIT_ENDPOINT}/subreddits/default.json`;\r\n        const response = await fetch(url, {\r\n            method: 'GET',\r\n            headers: {\r\n                Accept: 'application/json'\r\n            }\r\n        });\r\n        if (!response.ok) {\r\n            throw new Error(`RedditService getDefaultSubreddits failed, HTTP status ${response.status}`);\r\n        }\r\n        const data = await response.json();\r\n        const children = _.get(data, 'data.children');\r\n        if (!children) {\r\n            throw new Error(`RedditService getDefaultSubreddits failed, children not returned`);\r\n        }\r\n        return _.map(children, (subreddit) => {\r\n            // abstract away the specifics of the reddit API response and take only the fields we care about\r\n            return {\r\n                title: _.get(subreddit, 'data.display_name'),\r\n                description: _.get(subreddit, 'data.public_description'),\r\n                url: _.get(subreddit, 'data.url')\r\n            }\r\n        });\r\n    }\r\n\r\n    async getPostsFromSubreddit(subredditUrl) {\r\n        const url = `${REDDIT_ENDPOINT}${subredditUrl}hot.json`;\r\n        const response = await fetch(url, {\r\n            method: 'GET',\r\n            headers: {\r\n                Accept: 'application/json'\r\n            }\r\n        });\r\n        if (!response.ok) {\r\n            throw new Error(`RedditService getPostsFromSubreddit failed, HTTP status ${response.status}`);\r\n        }\r\n        const data = await response.json();\r\n        const children = _.get(data, 'data.children');\r\n        if (!children) {\r\n            throw new Error(`RedditService getPostsFromSubreddit failed, children not returned`);\r\n        }\r\n        return _.map(children, (post) => {\r\n            // abstract away the specifics of the reddit API response and take only the fields we care about\r\n            const body = _.get(post, 'data.selftext_html');\r\n            return {\r\n                id: _.get(post, 'data.id'),\r\n                title: _.get(post, 'data.title'),\r\n                topicUrl: subredditUrl,\r\n                body: body,\r\n                thumbnail: this._validateUrl(_.get(post, 'data.thumbnail')),\r\n                url: !body ? this._validateUrl(_.get(post, 'data.url')) : undefined\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    _validateUrl(url = '') {\r\n        return url.startsWith('http') ? url : undefined;\r\n    }\r\n}\r\n\r\nexport default new RedditService()","import Immutable from 'seamless-immutable';\r\nimport * as types from './actionTypes';\r\nimport _ from 'lodash';\r\n\r\nconst initialState = Immutable({\r\n    topicsByUrl: undefined,\r\n    selectedTopicUrls: [],\r\n    selectionFinalized: false\r\n})\r\n\r\nexport default function reduce(state = initialState, action = {}) {\r\n    switch (action.type) {\r\n        case types.TOPICS_FETCHED:\r\n            return state.merge({\r\n                topicsByUrl: action.topicsByUrl\r\n            })\r\n        case types.TOPICS_SELECTED:\r\n            return state.merge({\r\n                selectedTopicUrls: action.selectedTopicUrls\r\n            })\r\n        case types.TOPICS_SELECTION_FINILIZED:\r\n            return state.merge({\r\n                selectionFinalized: true\r\n            })\r\n        default:\r\n            return state\r\n    }\r\n}\r\n\r\n// селекторы\r\nexport const getTopicsByUrl = (state) => {\r\n    return state.topics.topicsByUrl\r\n}\r\n\r\nexport const getTopicsUrlArray = (state) => {\r\n    return _.keys(state.topics.topicsByUrl)\r\n}\r\n\r\nexport const getSelectedTopicUrls = (state) => {\r\n    return state.topics.selectedTopicUrls;\r\n}\r\n\r\nexport function getSelectedTopicsByUrl(state) {\r\n    return _.mapValues(_.keyBy(state.topics.selectedTopicUrls), (topicUrl) => state.topics.topicsByUrl[topicUrl]);\r\n  }\r\n\r\nexport const isTopicSelectionValid = (state) => state.topics.selectedTopicUrls.length === 3\r\n\r\nexport const isTopicSelectionFinalized = (state) => state.topics.selectionFinalized","import _ from 'lodash';\r\nimport React from 'react'\r\n\r\n\r\nconst ListView = (props) => {\r\n\r\n    const renderRowById = (renderRow, rowsById, rowId) => {\r\n        return (\r\n            <li key={rowId}>\r\n                {renderRow(rowId, _.get(rowsById, rowId))}\r\n            </li>\r\n        )\r\n    }\r\n\r\n    return(\r\n        <ul>\r\n           {props.rowsIdArray.map(rowId => renderRowById(props.renderRow, props.rowsById, rowId))}\r\n        </ul>\r\n    )\r\n}\r\n\r\nexport default ListView","import React from 'react'\r\n\r\nconst ListRow = (props) => {\r\n    const onClick = () =>{\r\n        props.onClick(props.rowId)\r\n    }\r\n\r\n    const backgroundColor = props.selected ? '#c0f0ff' : '#fff';\r\n    return (\r\n        <div\r\n            style={{backgroundColor }}\r\n            onClick = {onClick}\r\n        >\r\n            {props.children}\r\n        </div>\r\n    )\r\n}\r\nexport default ListRow","import React, { useEffect } from 'react'\r\nimport { connect } from 'react-redux'\r\nimport './TopicsScreen.css';\r\nimport * as topicsActions from '../store/topics/actions';\r\nimport * as topicsSelectors from '../store/topics/reducer';\r\nimport ListView from '../components/ListView';\r\nimport ListRow from '../components/ListRow';\r\n\r\n\r\n\r\nconst TopicsScreen = (props) => {\r\n\r\n    console.log(props)\r\n    const { dispatch } = props\r\n\r\n    //component did mount\r\n    useEffect(() => {\r\n        console.log('fetch')\r\n        dispatch(topicsActions.fetchTopics())\r\n    }, [dispatch])\r\n\r\n    const renderLoading = () => <p>Loading...</p>\r\n\r\n\r\n    const onRowClick = (rowId) => {\r\n        dispatch(topicsActions.selectTopic(rowId))\r\n    }\r\n\r\n    const renderRow = (rowId, row) => {\r\n        const selected = props.selectedRowsById[rowId]\r\n        return (\r\n            <ListRow\r\n                rowId={rowId}\r\n                onClick={onRowClick}\r\n                selected={selected}>\r\n\r\n                <h3>{row.title}</h3>\r\n                <p>{row.description}</p>\r\n\r\n            </ListRow>\r\n        )\r\n    }\r\n\r\n    const onNextScreenClick = () => {\r\n        dispatch(topicsActions.finalizeTopicsSelection())\r\n    }\r\n\r\n    if (!props.rowsById) {\r\n        console.log('loading...')\r\n        return renderLoading()\r\n    }\r\n\r\n    return (\r\n        <div className='TopicsScreen'>\r\n             <h3>Choose 3 topics of interest</h3>\r\n            <ListView\r\n                rowsIdArray={props.rowsIdArray}\r\n                rowsById={props.rowsById}\r\n                renderRow={renderRow} />\r\n\r\n            {props.canFinalizeSelction &&\r\n                <button className='NextScreen' onClick={onNextScreenClick} />}\r\n        </div>\r\n    )\r\n\r\n\r\n}\r\n\r\n// пропсы, которые мы хотим получить из глобального стора\r\nconst mapStateToProps = (state) => {\r\n    return {\r\n        rowsById: topicsSelectors.getTopicsByUrl(state),\r\n        rowsIdArray: topicsSelectors.getTopicsUrlArray(state),\r\n        selectedRowsById: topicsSelectors.getSelectedTopicsByUrl(state),\r\n        canFinalizeSelction: topicsSelectors.isTopicSelectionValid(state)\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(TopicsScreen)\r\n\r\n","import _ from 'lodash'\r\nimport * as types from './actionTypes';\r\nimport redditService from '../../services/reddit';\r\nimport * as topicsSelectors from './reducer';\r\n\r\n\r\nexport function fetchTopics(){\r\n    return async(dispatch, getState) =>{\r\n        try{\r\n            const subredditArray = await redditService.getDefaultSubreddits()\r\n            const topicsByUrl = _.keyBy(subredditArray, (subreddit) => subreddit.url)\r\n            dispatch({type:types.TOPICS_FETCHED, topicsByUrl})\r\n        }catch(error){\r\n            console.error(error)\r\n        }\r\n    }    \r\n}\r\n\r\nexport function selectTopic(topicUrl){\r\n    return (dispatch, getState) => {\r\n        const selectedTopics = topicsSelectors.getSelectedTopicUrls(getState())\r\n        if (_.indexOf(selectedTopics, topicUrl) !== -1) return\r\n\r\n        const newSelectedTopics = selectedTopics.length < 3 ?\r\n            selectedTopics.concat(topicUrl) :\r\n            selectedTopics.slice(1).concat(topicUrl)\r\n\r\n        dispatch({type: types.TOPICS_SELECTED, selectedTopicUrls : newSelectedTopics})\r\n    }\r\n}\r\n\r\nexport function finalizeTopicsSelection(){   \r\n    return ({type:types.TOPICS_SELECTION_FINILIZED})\r\n}","export const POSTS_FETCHED = 'posts.POSTS_FETCHED'\r\nexport const FILTER_CHANGED = 'posts.FILTER_CHANGED'\r\nexport const POST_SELECTED = 'posts.POST_SELECTED'","import _ from 'lodash';\r\nimport Immutable from 'seamless-immutable'\r\nimport * as types from './actionTypes';\r\n\r\nconst initialState = Immutable({\r\n    postsById: undefined,\r\n    currentFilter: \"all\",\r\n    currentPostId: undefined\r\n})\r\n\r\nexport default function reduce(state = initialState, action = {}) {\r\n    switch (action.type) {\r\n        case types.POSTS_FETCHED:\r\n            return state.merge({\r\n                postsById: action.postsById\r\n            })\r\n        case types.FILTER_CHANGED:\r\n            return state.merge({\r\n                currentFilter: action.filter\r\n            })\r\n        case types.POST_SELECTED:\r\n            return state.merge({\r\n                currentPostId: action.postId\r\n            });\r\n        default:\r\n            return state\r\n    }\r\n}\r\n\r\nexport const getPosts = (state) => {\r\n\r\n    const currentFilter = state.posts.currentFilter\r\n    const postsById = state.posts.postsById\r\n\r\n    const postsIdArray = currentFilter === 'all' ?\r\n        _.keys(postsById) :\r\n        _.filter(_.keys(postsById), postId => postsById[postId].topicUrl === currentFilter)\r\n    return [postsById, postsIdArray]\r\n}\r\n\r\nexport function getCurrentFilter(state) {\r\n    return state.posts.currentFilter\r\n}\r\n\r\nexport function getCurrentPost(state) {\r\n    return _.get(state.posts.postsById, state.posts.currentPostId)\r\n}","import _ from 'lodash';\r\nimport React from 'react'\r\n\r\n\r\nconst TopicFilter = (props) => {\r\n\r\n    const renderFilter = (id, label) => {\r\n        const className = props.selected === id ? 'selected' : undefined;\r\n        return (\r\n            <a\r\n                key={id}\r\n                href='#'\r\n                className={className}\r\n                onClick={() => onFilterClick(id)}\r\n            >\r\n                {label}\r\n            </a>\r\n        )\r\n    }\r\n    \r\n    const onFilterClick = (id, selected) => {\r\n        if (id === selected) return\r\n        props.onChanged(id)\r\n    }\r\n\r\n    return (\r\n        <div className={props.className}>\r\n            {renderFilter('all', 'All')}\r\n            {_.map(props.topics, (topic, topicId) => renderFilter(topicId, topic.title))}\r\n        </div>\r\n    )\r\n}\r\n\r\n\r\n\r\n\r\nexport default TopicFilter","import React, { Component } from 'react';\r\n\r\nexport default class PostView extends Component {\r\n\r\n  render() {\r\n    if (!this.props.post) return this.renderEmpty();\r\n    if (this.props.post.body) return this.renderBody();\r\n    else if (this._isImage(this.props.post.url)) return this.renderImage();\r\n    else return this.renderUrl();\r\n  }\r\n\r\n  renderEmpty() {\r\n    return (\r\n      <div>\r\n        <h3>Select a post to view</h3>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  renderBody() {\r\n    return (\r\n      <div dangerouslySetInnerHTML={this._getBodyMarkup(this.props.post.body)} />\r\n    );\r\n  }\r\n\r\n  renderImage() {\r\n    return (\r\n      <img src={this.props.post.url} alt={this.props.post.title} />\r\n    );\r\n  }\r\n\r\n  renderUrl() {\r\n    return (\r\n      <div>\r\n        <h3>External Link</h3>\r\n        <a href={this.props.post.url} target=\"_blank\">Open</a>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  _getBodyMarkup(body) {\r\n    return {\r\n      __html: body.replace(/&#(\\d+);/g, (match, dec) => String.fromCharCode(dec)).replace(/&amp;/g, '&').replace(/&lt;/g, '<').replace(/&gt;/g, '>').replace(/&quot;/g, '\"')\r\n    }\r\n  }\r\n\r\n  _isImage(url) {\r\n    if (!url) return false;\r\n    return (url.endsWith('.jpg') || url.endsWith('.gif') || url.endsWith('.png'));\r\n  }\r\n\r\n}","import React, { useEffect } from 'react'\r\nimport { connect } from 'react-redux'\r\nimport './PostsScreen.css'\r\nimport * as postsActions from '../store/posts/actions';\r\nimport * as postsSelectors from '../store/posts/reducer';\r\nimport * as topicsSelectors from '../store/topics/reducer';\r\nimport ListView from '../components/ListView';\r\nimport ListRow from '../components/ListRow';\r\nimport TopicFilter from '../components/TopicFilter';\r\nimport PostView from './../components/PostView'\r\n\r\nconst PostsSreen = (props) => {\r\n\r\n    const { dispatch } = props\r\n\r\n    useEffect(() => {\r\n        dispatch(postsActions.fetchPosts())\r\n    }, [dispatch])\r\n\r\n    const renderLoading = () => <p>Loading...</p>\r\n\r\n    const renderRow = (rowId, row) => {\r\n\r\n        const selected = props.currentPost === row\r\n        return (\r\n\r\n            <ListRow\r\n                rowId={rowId}\r\n                onClick={onRowClick}\r\n                selected={selected}\r\n            >\r\n                {!row.thumbnail ? false :\r\n                    <img className=\"thumbnail\" src={row.thumbnail} alt='thumbnail' />\r\n                }\r\n                <h3>{row.title}</h3>\r\n            </ListRow>\r\n        )\r\n    }\r\n\r\n    const onFilterChanged = (newFilter) => {\r\n        dispatch(postsActions.changeFilter(newFilter))\r\n    }\r\n\r\n    const onRowClick = (rowId) => {\r\n        \r\n        dispatch(postsActions.selectPost(rowId))\r\n    }\r\n\r\n    if (!props.rowsById) return renderLoading()\r\n\r\n    return (\r\n        <div className='PostsScreen'>\r\n            <div className='LeftPane'>\r\n                <TopicFilter\r\n                    className='TopicFilter'\r\n                    topics={props.topicsByUrl}\r\n                    selected={props.currentFilter}\r\n                    onChanged={onFilterChanged} />\r\n                <ListView\r\n                    rowsIdArray={props.rowIdArray}\r\n                    rowsById={props.rowsById}\r\n                    renderRow={renderRow} />\r\n            </div>\r\n            <div className='ContentPane'>\r\n                <PostView post={props.currentPost} />\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nconst mapStateToProps = (state) => {\r\n    const [postsById, postsIdArray] = postsSelectors.getPosts(state)\r\n    return {\r\n        rowsById: postsById,\r\n        rowIdArray: postsIdArray,\r\n        topicsByUrl: topicsSelectors.getSelectedTopicsByUrl(state),\r\n        currentFilter: postsSelectors.getCurrentFilter(state),\r\n        currentPost: postsSelectors.getCurrentPost(state)\r\n    }\r\n}\r\n\r\nexport default connect(mapStateToProps)(PostsSreen)","import _ from 'lodash';\r\nimport * as types from './actionTypes';\r\nimport redditService from '../../services/reddit';\r\nimport * as topicsSelectors from '../topics/reducer';\r\n\r\nexport function fetchPosts() {\r\n    return async (dispatch, getState) => {\r\n        try {\r\n            const selectedTopicsUrls = topicsSelectors.getSelectedTopicUrls(getState())\r\n            const fetchedPromises = _.map(selectedTopicsUrls, (topicUrl) => redditService.getPostsFromSubreddit(topicUrl))\r\n            const topicsPosts = await Promise.all(fetchedPromises)\r\n            const postsById = _.keyBy(_.flatten(topicsPosts), post => post.id)\r\n            dispatch({ type: types.POSTS_FETCHED, postsById })\r\n        } catch (error) {\r\n            console.log(error)\r\n        }\r\n    }\r\n}\r\n\r\nexport function changeFilter(newFilter) {\r\n    return ({ type: types.FILTER_CHANGED, filter: newFilter })\r\n}\r\n\r\nexport function selectPost(postId) {\r\n    return ({ type: types.POST_SELECTED, postId })\r\n}","import React from 'react';\nimport { connect } from 'react-redux';\nimport './App.css';\nimport TopicsScreen from './containers/TopicsScreen';\nimport PostsSreen from './containers/PostsScreen';\nimport * as topicsSelectors from './store/topics/reducer';\n\nconst App = (props) => {\n  return (\n    <div className=\"App\">\n      {!props.isSelectionFinilized ?\n        <TopicsScreen /> :\n        <PostsSreen />\n      }\n    </div>\n  );\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    isSelectionFinilized: topicsSelectors.isTopicSelectionFinalized(state)\n  }\n}\n\nexport default connect(mapStateToProps)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport { createStore, applyMiddleware, combineReducers } from 'redux'\nimport { Provider } from 'react-redux';\nimport thunk from 'redux-thunk';\n\nimport * as reducers from './store/reducers'\n\nconst store = createStore(combineReducers(reducers), applyMiddleware(thunk))\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}